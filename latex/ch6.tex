\chapter{Результаты}

Результатами работы является описание архитектуры (приведенное в тексте диплома) и реализация симулятора доступная на github: \url{https://github.com/ffloyd/evergrid-go}.

Код симулятора продокументирован для облегчения его последующей разработки и модификации. Технические тонкости реализации и более подробное рассмотрение принципов работы отдельных компонентов вынесены за рамки текста диплома и являются частью документации.

Удобная он-лайн версия документации доступна по адресу: \url{https://godoc.org/github.com/ffloyd/evergrid-go}.

Помимо описания работы компонентов, в документации даны рекомендации по путям эффективной модификации и расширения системы.

При реализации описанной в предыдущей главе модели go показал себя с сильной стороны. Модель параллелизма CSP оказалась крайне удобной для реализации многоагентной системы как с точки зрения внутренней архитектуры, так и с точки зрения получившегося API.

Реализованная как часть симулятора многоагентная среда получилась независимой от остального кода и может быть использована как база для написания других симуляторов.

При реализации для симулятора компонентов CoreUnit, Core и Worker было выявлено множество небольших технических аспектов, касающихся синхронизации работы компонентов. Причем эти аспекты будут актуальны и при написании реализаций этих компонентов для реальных условий. Этот факт подтверждает оправданность идеи, что необходимо тестировать не только сам планировщик, но и принципы взаимодействия остальных частей системы.

Эти тонкие моменты выражены в документации, которой сопровожден код и самом коде. В качестве примера приведу один из таких моментов: "если два последовательных запроса в систему оперируют одним датасетом или контейнером, то второй запрос должен быть послан в систему строго после окончания обработки первого Control Unit'ами". Конкретно этот пример связан с тем, что глобальное состояние системы должно полностью отражать изменения, привнесенные обработкой первого запроса. Иначе может оказаться, что мы, например, дважды запланируем загрузку одного и того же датасета на один Worker.

\section{Установка и использование evergrid-go}

Реализованный программный продукт называется evergrid-go и представляет из себя CLI-приложение (Command Line Interface).

Ниже описан наиболее простой сценарий для установки разработанного симулятора и примеры его использования.

Для начала нам надо установить go и настроить его окружение. Инструкции есть на сайте языка программирования go: \url{https://golang.org/doc/install}. Упрощенный способ для установки на Ubuntu: \url{https://github.com/golang/go/wiki/Ubuntu}

Когда окружение настроено скачиваем и устанавлваем актуальную версию evergrid-go следующей командой:

\begin{lstlisting}[language=bash]
go get github.com/ffloyd/evergid-go
\end{lstlisting}

После этого генерируем сценарий работы (со стандартными настройками) в папке simdata:

\begin{lstlisting}[language=bash]
$GOPATH/bin/evergrid-go gendata test simdata
\end{lstlisting}

Поменять параметры генерации можно через опции, список которых можно увидеть с помощью команды:

\begin{lstlisting}[language=bash]
$GOPATH/bin/evergrid-go gendata -h
\end{lstlisting}

Далее можно запустить симуляции для различных типов планировщика:

\begin{lstlisting}[language=bash]
$GOPATH/bin/evergrid-go simulator simdata/test.yaml -s random
$GOPATH/bin/evergrid-go simulator simdata/test.yaml -s naivefast
$GOPATH/bin/evergrid-go simulator simdata/test.yaml -s naivecheap
\end{lstlisting}

\section{Пример работы}

Ниже приведены примеры результатов работы симуляции на одинаковом сценарии для всех трех тривиальных реализаций планировщика.

Показаны только последние строчки логов, которые содержат статистику использования воркеров.

Как будет видно, планировщики дают результаты соответсвующие их целям. Naive Fast имеет наименьшее значение ''total calculating ticks'', Naive Cheap имеет наименьшее значение ''total money spent'', а все три запуска random scheduler оказались существенно хуже по этим параметрам.

Данные результаты представлены в ознакомительных целях, а сами планировщики представляют из себя довольно наивные реализации, которые не предназначены для работы в реальных условиях.

\subsection{Random Scheduler}

При запросе на загрузку датасета выбирается один случайный воркер и датасет загружается на него.

При запросе на выполнение эксперимента - эксперимент запускается на воркере с уже загруженным датасетом.

Так как работа планировщика рандомизирована приведены результаты трех запусков. Остальные два планировщика выдают одинаковый результат при условии одинакового сценария.

\begin{lstlisting}[caption=Random Scheduler: запуск 1]
Total uploading ticks          simulation=big value=269
Total building ticks           simulation=big value=82
Total calculating ticks        simulation=big value=5336
Total money spent              simulation=big value=4158.3458
\end{lstlisting}

\begin{lstlisting}[caption=Random Scheduler: запуск 2]
Total uploading ticks          simulation=big value=269
Total building ticks           simulation=big value=83
Total calculating ticks        simulation=big value=4450
Total money spent              simulation=big value=2670.4092
\end{lstlisting}

\begin{lstlisting}[caption=Random Scheduler: запуск 3]
Total uploading ticks          simulation=big value=269
Total building ticks           simulation=big value=85
Total calculating ticks        simulation=big value=5353
Total money spent              simulation=big value=3992.3984
\end{lstlisting}

\subsection{Naive Fast Scheduler}

При запросе на загрузку датасета выбираются три наиболее производительных воркера с размером очереди меньше пяти, либо просто три наиболее производительных воркера.

При запросе на выполнение эксперимента - среди воркеров с загруженным (или с запланированным для загрузки) датасетом выбирается наиболее быстрый с размером очереди меньше 5-и, либо просто наиболее быстрый из воркеров с минимальной очередью, если это невозможно.

\begin{lstlisting}[caption=Naive Fast Scheduler]
Total uploading ticks          simulation=big value=807
Total building ticks           simulation=big value=55
Total calculating ticks        simulation=big value=1611
Total money spent              simulation=big value=1361.8439
\end{lstlisting}

\subsection{Naive Cheap Scheduler}

При запросе на загрузку датасета выбираются три наиболее дешевых воркера с размером очереди меньше пяти,
либо просто три наиболее дешевых воркера.

Сравнивается цена за одну минуту работы.

При запросе на выполнение эксперимента - среди воркеров с загруженным (или с запланированным для загрузки) датасетом выбирается наиболее дешевый с размером очереди меньше 5-и, либо просто наиболее дешевый из воркеров с минимальной очередью, если это невозможно.


\begin{lstlisting}[caption=Naive Cheap Scheduler]
Total uploading ticks          simulation=big value=807
Total building ticks           simulation=big value=63
Total calculating ticks        simulation=big value=2574
Total money spent              simulation=big value=497.4759
\end{lstlisting}