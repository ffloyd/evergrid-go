\chapter{Сравнение с существующими решениями}

В рамках работы была рассмотрена возможность использования или модификации существующего решения вместо написания своей реализации. Для корректного сравнения стоит сразу перечислить преимущества написания своей реализации на go. Если взять во внимание тот факт, что подобных приложений на go найдено не было, то преимущества таковы:

\begin{itemize}
	\item возможность использовать один код планировщика как для симуляции, так и для реального окружения - это дает дополнительные гарантии корректности его реализации
	\item удобная возможность записи реальных сценариев работы и последующей симуляции их с различными вариантами планировщиков
	\item go - простой в использовании язык и имеет встроенную модель параллелизма CSP, это облегчает разработку и модификацию кода симуляции
	\item go - быстрый язык, скорость его работы сравнима с C/C++
	\item в go встроен автоматический детектор состояний гонки
	\item go популярен для микросервисов, но на данный момент нет ни одного симулятора для go
\end{itemize}

Следует понимать, что использование или модификация готового решения должны предоставлять преимущества, перевешивающие этот список.

\section{NetLogo}

NetLogo\cite{tisue2004netlogo} - очень известное решение для моделирования и исследования работы многоагентных систем. Его преимущество состоит в развитых инструментах визуализации.

Но для решения конкретной задачи NetLogo подходит плохо, т. к.:

\begin{itemize}
	\item NetLogo использует свой язык программирования. Это язык узкого назначения и писать на нем менее удобно, чем на популярных языках общего назначения
	\item мы симулируем не только scheduler, но и прочие компоненты системы. Нам важно, чтобы модель общения между ними была приближена к реальной. Это дает возможности для поиска состояний гонки в рамках архитектуры в целом. Реализация честного общения всех компонентов довольно сложна на NetLogo и потенциально сложнее написания своей реализации на go.
	\item у него низкая скорость работы
\end{itemize}

\section{Узкоспециализированные симуляторы: SimGrid, GridSim, ALEA 2}

Среди более узкоспециализированных решений было найдено три кандидата: SimGrid\cite{casanova2001simgrid}, GridSim\cite{GridSim} и ALEA 2\cite{ALEA}.

Эти продукты реализованы на Java (GridSim, ALEA 2) и C (SimGrid). У всех трех есть один критический недостаток: без модификации исходного кода невозможно реализовать поставленную задачу - архитектура проекта слишком специфична. А сама задача их модификации получается сложнее, чем написание своего решения. Также усложняется и сопровождение получившегося симулятора - вносить правки тяжелее по двум причинами: Java и C менее удобны чем go, больший шанс неожиданных ошибок в виду возможных конфликтов с изначальной архитектурой симулятора.

Еще одна особенность всех трех симуляторов - они сверхсконцентрированы на анализе планировщика, в то время как одной из наших задач является и анализ архитектуры в целом.

Также есть проблемы специфичные для каждого из решений:

\subsection{GridSim}

Дата последнего обновления - 2010й год. Видимо, проект более не поддерживается, и при возникновении незадокументированных проблем трудно будет связаться с его разработчиком.

Также при использовании GridSim будет проблематично симулировать "динамическое" окружение - разрывы сети, меняющийся список воркеров и прочее.

Итого: суммарная сложность модификации и поддержки решения на GridSim потенциально выше сложности написания и поддержки своей реализации на go. При этом мы еще жертвуем вышеописанными преимуществами своей реализации.

\subsection{ALEA 2}

ALEA 2 является модификацией GridSim, и ее использование сопряжено с теми же проблемами. В отличие от GridSim, она еще поддерживается разработчиками.

\subsection{SimGrid}

Наиболее активно поддерживаемый продукт, но более узкоспециализирован, чем два других. Количество модификаций, которые необходимо будет внести, существенно больше - что  усложняет его адаптацию.

К тому же, из соображений скорости он написан на С, а модифицировать код на С обычно сложнее, чем модифицировать код на Java.